import "config.scrypt";
import "bootloader.scrypt";
import "fri.scrypt";
import "primeField.scrypt";


// TODO: Try to reduce writes to verifier state. 
//       If not possible, then verifier state should probably a bytes instead of int[].


struct ProofParams {
    int nQueries;
    int logBlowupFactor;
    int powBits;
    int friLastLayerDegBound;
    int nFriSteps;
    int[Config.MAX_FRI_STEPS] friSteps;
}

struct Proof {
    int proofSize;
    int[Config.MAX_PROOF_SIZE] vals;
}

struct TastMetadata {
    int nTasks;
    int[Config.MAX_TASKS] nTreePairs;
    int[Config.MAX_TASKS] taskOutputSizes;
    int[Config.MAX_TASKS] programHashes;
}

struct CairoAuxInput {
    int ecdsaBeginAddr;
    int ecdsaStopPtr;
    int publicMemoryPaddingAddr;
    int publicMemoryPaddingValue;
    int nPublicMemoryPages;
    int executionBeginAddr;
    int executionStopPtr;
    int builtinStartPtr;
    int builtinStopPtr;
    int outputBeginAddr;
    int outputStopPtr;
    int programBeginAddr;
    int programStopPtr;
    int initialPc;
    int finalPc;
    int logNSteps;
    int rcMin;
    int rcMax;
    int pedersenBeginAddr;
    int pedersenStopPtr;
    int rangeCheckBeginAddr;
    int rangeCheckStopPtr;
    int z;
    int alpha;
    MemoryPage[Config.MAX_PUBLIC_INPUT_MEMORY_PAGES] publicMemoryPages;
}

struct MemoryPage {
    int firstAddress;
    int pageSize;
    int pageHash;
    int cumulativeProduct;
}

struct OutputRegisterPubMainPage {
    int publicMemoryLenght;
    Fact pageFact;
}

struct GPSVerifierConstructorArgs {
    int simpleBootloaderProgramHash;
    int hashedSupportedCairoVerifiers;
}

struct Fact {
    int memoryHash;
    int prod;
}

library GPSStatementVerifier {

    /*
      A fact for the claim:
        I know n pairs (addr, value) for which the hash of the pairs is memoryHash, and the cumulative
        product: \prod_i( z - (addr_i + alpha * value_i) ) is prod.
    */
    static function computeFact(
                int[Config.MAX_PUBLIC_MEMORY_WORDS] publicMemory,
                int offset,
                int z,
                int alpha) : Fact {
        int prime = PrimeFieldElement.K_MODULUS;
        int memSize = offset / 2;
        int prod = 1;
        int lastIdx = offset - 1;

        bool end = false;
        loop (Config.MAX_PUBLIC_MEMORY_WORDS) : i {
            if (i >= memSize) {
                end = true;
            }
            if (!end) {
                int idx = i * 2;
                // Compute address + alpha * value
                int addrValLinearComb = PrimeFieldElement.fadd(
                                        publicMemory[idx],
                                        PrimeFieldElement.fmul(
                                                publicMemory[idx + 1],
                                                alpha)
                                        );

                prod = PrimeFieldElement.fmul(prod, z + prime - addrValLinearComb);
            }
        }


        // TODO: Serialize to bytes and hash keccak256.

        return {0, 0};
    }

    static function registerPublicMemoryMainPage(
            TastMetadata taskMetadata,
            CairoAuxInput cairoAuxInput,
            GPSVerifierConstructorArgs constArgs) : OutputRegisterPubMainPage {

        int publicMemoryLenght = Bootloader.COMPILED_BOOTLOADER_LEN + 
                                 // return fp and pc =
                                 2 +
                                 Config.N_MAIN_ARGS +
                                 Config.N_MAIN_RETURN_VALUES +
                                 // Bootloader config size =
                                 2 +
                                 // Number of tasks cell =
                                 1 +
                                 2 *
                                 taskMetadata.nTasks;

        int[Config.MAX_PUBLIC_MEMORY_WORDS] publicMemory = repeat(0, Config.MAX_PUBLIC_MEMORY_WORDS);
        int offset = 0;

        // Write bootloader program to public memory.
        // TODO: This could be predefined at compile time.
        loop (Bootloader.COMPILED_BOOTLOADER_LEN) : i {
            publicMemory[offset] = i + Config.INITIAL_PC;
            publicMemory[offset + 1] = Bootloader.COMPILED_BOOTLOADER[i];
            offset += 2;
        }

        // Execution segment - Make sure [initial_fp - 2] = initial_fp and .
        // This is required for the "safe call" feature (that is, all "call" instructions will
        // return, even if the called function is malicious).
        // It guarantees that it's not possible to create a cycle in the call stack.
        int initialFp = cairoAuxInput.executionBeginAddr;
        require(initialFp >= 2);

        publicMemory[offset + 0] = initialFp - 2;
        publicMemory[offset + 1] = initialFp;
        // Make sure [initial_fp - 1] = 0.
        publicMemory[offset + 2] = initialFp - 1;
        publicMemory[offset + 3] = 0;
        offset += 4;

        // Enforce main's arguments and return values.
        // Note that the page hash depends on the order of the (address, value) pair in the
        // publicMemory and consequently the arguments must be written before the return values.
        int returnValuesAddress = cairoAuxInput.executionStopPtr - Config.N_BUILTINS;

        loop (Config.N_BUILTINS) : i {
            // Write argument address.
            publicMemory[offset] = initialFp + i;
            int returnValuesOffset = offset + 2 * Config.N_BUILTINS;

            // Write return value offset.
            publicMemory[returnValuesOffset] = returnValuesAddress + i;

            // Write values.
            // TODO: Can get rid of branching because SELECTED_BUILTINS is known at compile time.
            if ((Config.SELECTED_BUILTINS & 1) != 0) {
                // Set the argument to the builtin start pointer.
                publicMemory[offset + 1] = cairoAuxInput.builtinStartPtr;
                // Set the return value to the builtin stop pointer.
                publicMemory[returnValuesOffset + 1] = cairoAuxInput.builtinStopPtr;
            } else {
                // Builtin is not present in layout, set the argument value and return value to 0.
                publicMemory[offset + 1] = 0;
                publicMemory[returnValuesOffset + 1] = 0;
            }
            offset += 2;
        }

        // Program output.
        int outputAddress = cairoAuxInput.outputBeginAddr;
        // Force that memory[outputAddress] and memory[outputAddress + 1] contain the
        // bootloader config (which is 2 words size).
        publicMemory[offset + 0] = outputAddress;
        publicMemory[offset + 1] = constArgs.simpleBootloaderProgramHash;
        publicMemory[offset + 2] = outputAddress + 1;
        publicMemory[offset + 3] = constArgs.hashedSupportedCairoVerifiers;
        publicMemory[offset + 4] = outputAddress + 2;
        publicMemory[offset + 5] = taskMetadata.nTasks;
        offset += 6;
        outputAddress += 3;

        bool end = false;
        loop (Config.MAX_TASKS) : task {
            if (task >= taskMetadata.nTasks) {
                end = true;
            }
            if (!end) {
                int outputSize = taskMetadata.taskOutputSizes[task];
                require(outputSize >= 2 && outputSize <= Config.MAX_OUTPUT_SIZE);
                int programHash = taskMetadata.programHashes[task];
                int nTreePairs = taskMetadata.nTreePairs[task];
                require(1 <= nTreePairs && nTreePairs <= Config.MAX_N_TREE_PAIRS);

                // Force that memory[outputAddress] = outputSize.
                publicMemory[offset + 0] = outputAddress;
                publicMemory[offset + 1] = outputSize;
                // Force that memory[outputAddress + 1] = programHash.
                publicMemory[offset + 2] = outputAddress + 1;
                publicMemory[offset + 3] = programHash;
                offset += 4;
                outputAddress += outputSize;
            }
        }

        require(cairoAuxInput.outputStopPtr == outputAddress);

        // Register memory page.
        require((offset + 1) % 2 == 0); // Size of memory pairs must be even.
        require(cairoAuxInput.z < PrimeFieldElement.K_MODULUS);
        require(cairoAuxInput.alpha < PrimeFieldElement.K_MODULUS);

        Fact pageFact = computeFact(publicMemory, 
                                    offset,
                                    cairoAuxInput.z,
                                    cairoAuxInput.alpha);

        // TODO: Do we need to keep a registry?
        //registry.

        return { publicMemoryLenght, pageFact };
    }

    static function initVerifierParams(CairoAuxInput cairoAuxInput, ProofParams proofParams) : int[Config.MM_CONTEXT_SIZE] {
        int[Config.MM_CONTEXT_SIZE] verifierState = repeat(0, Config.MM_CONTEXT_SIZE);
        
        require(proofParams.logBlowupFactor <= 16 && proofParams.logBlowupFactor >= 1);
        require(proofParams.powBits <= 50 && proofParams.powBits >= Config.MIN_PROOF_OF_WORK_BITS);
        require(proofParams.powBits < Config.NUM_SECURITY_BITS);

        require(proofParams.friLastLayerDegBound < 10);

        require(proofParams.nFriSteps <= 10 && proofParams.nFriSteps > 1);

        //// AIR specific init.
        // Context of generated code.
        verifierState[Config.MM_OFFSET_SIZE] = PrimeFieldElement.fpow(2, 16);
        verifierState[Config.MM_HALF_OFFSET_SIZE] = PrimeFieldElement.fpow(2, 15);

        // Number of steps.
        require(cairoAuxInput.logNSteps < 50);
        verifierState[Config.MM_LOG_N_STEPS] = cairoAuxInput.logNSteps;
        int logTraceLength = cairoAuxInput.logNSteps + Config.LOG_CPU_COMPONENT_HEIGHT;
        
        // Range check limits.
        verifierState[Config.MM_RC_MIN] = cairoAuxInput.rcMin;
        verifierState[Config.MM_RC_MIN] = cairoAuxInput.rcMax;
        require(cairoAuxInput.rcMin <= cairoAuxInput.rcMax);
        require(cairoAuxInput.rcMax <= Config.MM_OFFSET_SIZE);

        // Initial and final pc. ("program" memory segment)
        require(cairoAuxInput.programBeginAddr == cairoAuxInput.initialPc);
        require(cairoAuxInput.programStopPtr == cairoAuxInput.finalPc);
        verifierState[Config.MM_INITAL_PC] = cairoAuxInput.programBeginAddr;
        verifierState[Config.MM_FINAL_PC] = cairoAuxInput.programStopPtr;

        // Initial and final ap. ("execution" memory segment)
        verifierState[Config.MM_INITAL_AP] = cairoAuxInput.executionBeginAddr;
        verifierState[Config.MM_FINAL_AP] = cairoAuxInput.executionStopPtr;

        // "output" memory segment.
        require(cairoAuxInput.outputBeginAddr <= cairoAuxInput.outputStopPtr);
        int bit64 = PrimeFieldElement.fpow(2, 64);
        require(cairoAuxInput.outputStopPtr < bit64);

        // "Pedersen" memory segment.
        verifierState[Config.MM_INITAL_PEDERSEN_ADDR] = cairoAuxInput.pedersenBeginAddr;
        require(cairoAuxInput.pedersenBeginAddr < bit64);
        int pedersenMaxStopPtr = cairoAuxInput.pedersenBeginAddr + 3 *
                                        (PrimeFieldElement.fpow(2, cairoAuxInput.logNSteps) / Config.PEDERSEN_BUILTIN_RATIO);
        require(cairoAuxInput.pedersenBeginAddr <= cairoAuxInput.pedersenStopPtr);
        require(cairoAuxInput.pedersenStopPtr <= pedersenMaxStopPtr);

        // "range_check" memory segment.
        verifierState[Config.MM_INITIAL_RC_ADDR] = cairoAuxInput.rangeCheckBeginAddr;
        require(cairoAuxInput.rangeCheckBeginAddr < bit64);
        int rcMaxStopPtr = cairoAuxInput.rangeCheckBeginAddr + 
                            (PrimeFieldElement.fpow(2, cairoAuxInput.logNSteps) / Config.RC_BUILTIN_RATIO);
        require(cairoAuxInput.rangeCheckBeginAddr <= cairoAuxInput.rangeCheckStopPtr);
        require(cairoAuxInput.rangeCheckStopPtr <= rcMaxStopPtr);

        // "ecdsa" memory segment.
        verifierState[Config.MM_INITIAL_ECDSA_ADDR] = cairoAuxInput.ecdsaBeginAddr;
        require(cairoAuxInput.ecdsaBeginAddr < bit64);
        int ecdsaMaxStopPtr = cairoAuxInput.ecdsaBeginAddr + 
                            (PrimeFieldElement.fpow(2, cairoAuxInput.logNSteps) / Config.ECDSA_BUILTIN_RATIO);
        require(cairoAuxInput.ecdsaBeginAddr <= cairoAuxInput.ecdsaStopPtr);
        require(cairoAuxInput.ecdsaStopPtr <= ecdsaMaxStopPtr);

        // Public memory.
        require(cairoAuxInput.nPublicMemoryPages >= 1);
        require(cairoAuxInput.nPublicMemoryPages <= Config.MAX_PUBLIC_INPUT_MEMORY_PAGES);
        //verifierState[Config.MM_N_PUBLIC_MEM_PAGES] = cairoAuxInput.nPublicMemoryPages;

        // Compute the total number of public memory entries.
        int nPublicMemoryEntries = 0;
        bool loopActive = true;
        loop (Config.MAX_PUBLIC_INPUT_MEMORY_PAGES) : i {
            if (i >= cairoAuxInput.nPublicMemoryPages) {
                loopActive = false;
            }

            if (loopActive) {
               MemoryPage page = cairoAuxInput.publicMemoryPages[i];
               require(page.pageSize < PrimeFieldElement.fpow(2, 30));
               nPublicMemoryEntries += page.pageSize;
            }
        }
        verifierState[Config.MM_N_PUBLIC_MEM_PAGES] = nPublicMemoryEntries;

        // TODO: public input length check

        // Set public input pointer to point at the first word of the public input.
        verifierState[Config.MM_PUBLIC_INPUT_PTR] = Config.MM_CONTEXT_SIZE;
        loopActive = true;
        loop (Config.MAX_PUBLIC_INPUT_MEMORY_PAGES) : i {
            if (i >= cairoAuxInput.nPublicMemoryPages) {
                loopActive = false;
            }
            
            if (loopActive) {
                verifierState[i + 6] = cairoAuxInput.publicMemoryPages[i].pageHash; // TODO: what to push here?
            }
        }

        // Pedersen shift point values.
        verifierState[Config.MM_PEDERSEN_SHIFT_POINT_X] = 0x49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804;
        verifierState[Config.MM_PEDERSEN_SHIFT_POINT_Y] = 0x3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a;

        verifierState[Config.MM_RC16_PERM_PUBLIC_MEMORY_PROD] = 1;
        verifierState[Config.MM_ECDSA_SIG_CONFIG_ALPHA] = 1;
        verifierState[Config.MM_ECDSA_SIG_CONFIG_BETA] = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;
        verifierState[Config.MM_ECDSA_SIG_CONFIG_SHIFT_POINT_X] = 0x49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804;
        verifierState[Config.MM_ECDSA_SIG_CONFIG_SHIFT_POINT_Y] = 0x3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a;

        //// end - AIR specific init

        Fri.validateParams(proofParams.friSteps, proofParams.nFriSteps, logTraceLength, proofParams.friLastLayerDegBound);

        // Storing the fri steps at the end of the verifier context / state.
        int FRI_SEGMENT_START = 2386; // TODO: Pointer to the start of fri steps segment. This should be dynamic, check reference impl.
        verifierState[Confing.MM_FRI_STEPS_PTR] = FRI_SEGMENT_START; 
        verifierState[FRI_SEGMENT_START] = proofParams.nFriSteps;
        loopActive = true;
        loop (MAX_FRI_STEPS) : i {
            if (i > proofParams.nFriSteps) {
                loopActive = false;
            }
            if (loopActive) {
                verifierState[FRI_SEGMENT_START + i + 1] = proofParams.friSteps[i];
            }
        }

        require(proofParams.nQueries > 0);
        require(proofParams.nQueries <= Config.MAX_N_QUERIES;
        require(proofParams.nQueries * logBlowupFactor + powBits >= Config.NUM_SECURITY_BITS);

        verifierState[Config.MM_FRI_LAST_LAYER_DEG_BOUND] = PrimeFieldElement.fpow(2, proofParams.friLastLayerDegBound);
        verifierState[Config.MM_TRACE_LENGTH] = PrimeFieldElement.fpow(2, logTraceLength);
        verifierState[Config.MM_BLOW_UP_FACTOR] = PrimeFieldElement.fpow(2, logBlowupFactor);
        verifierState[Config.MM_PROOF_OF_WORK_BITS] = powBits;
        verifierState[Config.MM_N_UNIQUE_QUERIES] = proofParams.nQueries;
        verifierState[Config.MM_LOG_EVAL_DOMAIN_SIZE] = logTraceLength + logBlowupFactor;
        verifierState[Config.MM_EVAL_DOMAIN_SIZE] = PrimeFieldElement.fpow(2, verifierState[Config.MM_LOG_EVAL_DOMAIN_SIZE);
        verifierState[Config.MM_EVAL_DOMAIN_GENERATOR] = PrimeFieldElement.fpow(
                                    PrimeFieldElement.GENERATOR_VAL,
                                    (PrimeFieldElement.K_MODULUS - 1) / verifierState[Config.MM_EVAL_DOMAIN_SIZE]
                            );
        verifierState[Config.MM_TRACE_GENERATOR] = PrimeFieldElement.fpow(
                                    verifierState[Config.MM_EVAL_DOMAIN_GENERATOR],
                                    verifierState[Config.MM_BLOW_UP_FACTOR]
                            );

        return verifierState;
    }

    static function verifyProof(
            ProofParams proofParams,
            Proof proof,
            TastMetadata taskMetadata,
            CairoAuxInput cairoAuxInput,
            GPSVerifierConstructorArgs constArgs) : bool {

        // We are using verifier layout 1 by default.
        // https://github.com/starkware-libs/starkex-contracts/tree/master/evm-verifier/solidity/contracts/cpu/layout1

        // Register public memory main page.
        OutputRegisterPubMainPage outRegisterPubMainPage = registerPublicMemoryMainPage(
                                                            taskMetadata,
                                                            cairoAuxInput,
                                                            constArgs);

        // Make sure the main page is valid.
        require(cairoAuxInput.publicMemoryPages[0].pageSize == outRegisterPubMainPage.publicMemoryLenght);
        require(cairoAuxInput.publicMemoryPages[0].pageHash == outRegisterPubMainPage.pageFact.memoryHash);
        require(cairoAuxInput.publicMemoryPages[0].pageSize == outRegisterPubMainPage.pageFact.prod);

        // Verify proof 
        int[Config.MM_CONTEXT_SIZE] verifierState = initVerifierParams(cairoAuxInput, proofParams);

        // Store the proof at the end of the verifier state and store a pointer there.
        int PROOF_SEGMENT_START = 2394; // TODO
        int proofIdx = PROOF_SEGMENT_START;
        bool loopActive = true;
        loop (Config.MAX_PROOF_SIZE) : i {
            if (i > proof.proofSize) {
                loopActive = false;
            }
            if (loopActive) {
                verifierState[PROOF_SEGMENT_START + i + 1] = proof.vals[i];
            }
        }

        // Init the channel.
        verifierState = VerifierChannel.initChannel(proofIdx, cairoAuxInput.publicInputHash, verifierState);

        // Read trace commitment.
        int proofIdx = verifierState[Config.MM_CHANNEL];
        int val = verifierState[proofIdx];
        verifierState[Config.MM_CHANNEL] = proofIdx + 1;

        verifierState[Config.MM_CHANNEL + 2] = val;
        bytes bytes1 = num2bin(verifierState[Config.MM_CHANNEL + 1], 32);
        bytes bytes2 = num2bin(val, 32);
        verifierState[Config.MM_CHANNEL + 1] = sha256(bytes1 + bytes2);
        verifierState[Config.MM_CHANNEL + 2] = 0;

        verifierState[Config.MM_TRACE_COMMITMENT] = val;

        // Simulated interaction with prover.
        // Send interaction elements.
        verifierState = VerifierChannel.sendFieldElements(verifierState);


    
        return false;
    }
            

}

