import "config.scrypt";
import "bootloader.scrypt";


struct ProofParams {
    int nQueries;
    int logBlowupFactor;
    int powBits;
    int friLastLayerDegBound;
    int nFriSteps;
    int[Config.MAX_FRI_STEPS] friSteps;
}

struct Proof {
    int proofSize;
    int[Config.MAX_PROOF_SIZE] vals;
}

struct TastMetadata {
    int nTasks;
    int[Config.MAX_TASKS] taskOutputSizes;
    int[Config.MAX_TASKS] programHashes;
}

struct CairoAuxInput {
    int ecdsaBeginAddr;
    int ecdsaStopPtr;
    int publicMemoryPaddingAddr;
    int publicMemoryPaddingValue;
    int nPublicMemoryPages;
    int executionBeginAddr;
    int executionStopPtr;
    int builtinStartPtr;
    int builtinStopPtr;
    int outputBeginAddr;
    int outputStopAddr;
    int z;
    int alpha;
    MemoryPage[Config.MAX_PUBLIC_INPUT_MEMORY_PAGES] publicMemoryPages;
}

struct MemoryPage {
    int firstAddress;
    int pageSize;
    int pageHash;
    int cumulativeProduct;
}

struct OutputRegisterPubMainPage {
    int publicMemoryLenght;
    Fact pageFact;
}

struct GPSVerifierConstructorArgs {
    int simpleBootloaderProgramHash;
    int hashedSupportedCairoVerifiers;
}

struct Fact {
    int memoryHash;
    int prod;
}

library GPSStatementVerifier {

    /*
      A fact for the claim:
        I know n pairs (addr, value) for which the hash of the pairs is memoryHash, and the cumulative
        product: \prod_i( z - (addr_i + alpha * value_i) ) is prod.
    */
    function computeFact(
                int[Config.MAX_PUBLIC_MEMORY_WORDS] publicMemory,
                int offset,
                int z,
                int alpha) : Fact {
        int prime = PrimeFieldElement.K_MODULUS;
        int memSize = offset / 2;
        int prod = 1;
        int lastIdx = offset - 1;

        bool end = false;
        loop (Config.MAX_PUBLIC_MEMORY_WORDS) : i {
            if (i >= memSize) {
                end = true;
            }
            if (!end) {
                int idx = i * 2;
                // Compute address + alpha * value
                int addrValLinearComb = PrimeFieldElement.fadd(
                                        publicMemory[idx],
                                        PrimeFieldElement.fmul(
                                                publicMemory[idx + 1],
                                                alpha)
                                        );

                prod = PrimeFieldElement.fmul(prod, z + prime - addrValLinearComb);
            }
        }


        // TODO: Serialize to bytes and hash keccak256.


    }

    function registerPublicMemoryMainPage(
            TastMetadata taskMetadata,
            CairoAuxInput cairoAuxInput
            GPSVerifierConstructorArgs constArgs) : OutputRegisterPubMainPage {

        int publicMemoryLenght = Config.BOOTLOADER_PROGRAM_SIZE + 
                                 // return fp and pc =
                                 2 +
                                 Config.N_MAIN_ARGS +
                                 Config.N_MAIN_RETURN_VALUES +
                                 // Bootloader config size =
                                 2 +
                                 // Number of tasks cell =
                                 1 +
                                 2 *
                                 taskMetadata.nTasks);

        int[Config.MAX_PUBLIC_MEMORY_WORDS] publicMemory = repeat(0, Config.MAX_PUBLIC_MEMORY_WORDS);
        int offset = 0;

        // Write bootloader program to public memory.
        // TODO: This could be predefined at compile time.
        loop (Config.COMPILED_BOOTLOADER_LEN) : i {
            publicMemory[offset] = i + Config.INITIAL_PC;
            publicMemory[offset + 1] = Bootloader.COMPILED_BOOTLOADER[i];
            offset += 2;
        }

        // Execution segment - Make sure [initial_fp - 2] = initial_fp and .
        // This is required for the "safe call" feature (that is, all "call" instructions will
        // return, even if the called function is malicious).
        // It guarantees that it's not possible to create a cycle in the call stack.
        int initialFp = cairoAuxInput.executionBeginAddr;
        require(initialFp >= 2);

        publicMemory[offset + 0] = initialFp - 2;
        publicMemory[offset + 1] = initialFp;
        // Make sure [initial_fp - 1] = 0.
        publicMemory[offset + 2] = initialFp - 1;
        publicMemory[offset + 3] = 0;
        offset += 4;

        // Enforce main's arguments and return values.
        // Note that the page hash depends on the order of the (address, value) pair in the
        // publicMemory and consequently the arguments must be written before the return values.
        int returnValuesAddress = cairoAuxInput.executionStopPtr - Config.N_BUILTINS;

        loop (Config.N_BUILTINS) : i {
            // Write argument address.
            publicMemory[offset] = initialFp + i;
            int returnValuesOffset = offset + 2 * Config.N_BUILTINS;

            // Write return value offset.
            publicMemory[returnValuesOffset] = returnValuesAddress + i;

            // Write values.
            // TODO: Can get rid of branching because SELECTED_BUILTINS is known at compile time.
            if ((Config.SELECTED_BUILTINS & 1) != 0) {
                // Set the argument to the builtin start pointer.
                publicMemory[offset + 1] = cairoAuxInput.builtinStartPtr;
                // Set the return value to the builtin stop pointer.
                publicMemory[returnValueOffset + 1] = cairoAuxInput.builtinStopPtr;
            } else {
                // Builtin is not present in layout, set the argument value and return value to 0.
                publicMemory[offset + 1] = 0;
                publicMemory[returnValueOffset + 1] = 0;
            }
            offset += 2;
        }

        // Program output.
        int outputAddress = cairoAuxInput.outputBeginAddr;
        // Force that memory[outputAddress] and memory[outputAddress + 1] contain the
        // bootloader config (which is 2 words size).
        publicMemory[offset + 0] = outputAddress;
        publicMemory[offset + 1] = constArgs.simpleBootloaderProgramHash;
        publicMemory[offset + 2] = outputAddress + 1;
        publicMemory[offset + 3] = constArgs.hashedSupportedCairoVerifiers;
        publicMemory[offset + 4] = outputAddress + 2;
        publicMemory[offset + 5] = taskMetadata.nTasks;
        offset += 6;
        outputAddress += 3;

        bool end = false;
        loop (Config.MAX_TASKS) : task {
            if (task >= taskMetadata.nTasks) {
                end = true;
            }
            if (!end) {
                int outputSize = taskMetadata.taskOutputSizes[task];
                require(outputSize >= 2 && outputSize <= Config.MAX_OUTPUT_SIZE);
                int programHash = taskMetadata.programHashes[task];
                int nTreePairs = taskMetadata.nTreePairs[task];
                require(1 <= nTreePairs && nTreePairs <= Config.MAX_N_TREE_PAIRS);

                // Force that memory[outputAddress] = outputSize.
                publicMemory[offset + 0] = outputAddress;
                publicMemory[offset + 1] = outputSize;
                // Force that memory[outputAddress + 1] = programHash.
                publicMemory[offset + 2] = outputAddress + 1;
                publicMemory[offset + 3] = programHash;
                offset += 4;
                outputAddress += outputSize;
            }
        }

        require(cairoAuxInput.outputStopAddr == outputAddress);

        // Register memory page.
        require((offset + 1) % 2 == 0); // Size of memory pairs must be even.
        require(cairoAuxInput.z < PrimeFieldElement.K_MODULUS);
        require(cairoAuxInput.alpha < PrimeFieldElement.K_MODULUS);

        Fact pageFact = computeFact(publicMemory, 
                                    offset,
                                    cairoAuxInput.z,
                                    cairoAuxInput.alpha);

        // TODO: Do we need to keep a registry?
        //registry.

        return { publicMemoryLenght, memoryHash, pageFact };
    }


    function verifyProof(
            ProofParams proofParams,
            Proof proof,
            TastMetadata taskMetadata,
            CairoAuxInput cairoAuxInput,
            GPSVerifierConstructorArgs constArgs) : bool {

        // We are using verifier layout 1 by default.
        // https://github.com/starkware-libs/starkex-contracts/tree/master/evm-verifier/solidity/contracts/cpu/layout1

        // Register public memory main page.
        OutputRegisterPubMainPage outRegisterPubMainPage = registerPublicMemoryMainPage(
                                                            taskMetadata,
                                                            cairoAuxInput,
                                                            constArgs);

        // Make sure the main page is valid.
        require(cairoAuxInput.publicMemoryPages[0].size == outRegisterPubMainPage.publicMemoryLenght);
        require(cairoAuxInput.publicMemoryPages[0].pageHash == outRegisterPubMainPage.pageFact.memoryHash);
        require(cairoAuxInput.publicMemoryPages[0].pageSize == outRegisterPubMainPage.pageFact.prod);

        // TODO: verify proof 
        int[Config.MM_CONTEXT_SIZE] verifierState = repeat(0, Config.MM_CONTEXT_SIZE);
        verifierState =

    }
            

}

